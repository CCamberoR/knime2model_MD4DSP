"""
This script implements a graphical user interface (GUI) using Gradio
to visualize contract validation results from workflows generated by
KNIME and Python platforms. It provides automatic bar chart generation
based on selected configurations and exports the resulting images.

Modules:
- gradio: For creating the GUI interface.
- json: For reading structured data from JSON files.
- os: For managing file paths and directories.
- matplotlib.pyplot: For bar chart visualization.
- collections: For structured counting of node types and validation results.

Functionality:
- Reactive graph generation upon input change.
- Bar chart configuration by workflow, contract type, or node type.
- Chart export with descriptive filenames based on selected options.
"""

import gradio as gr
import json
import os
import matplotlib.pyplot as plt
from collections import defaultdict

# === Configuration ===

DATA_PATHS = {
    "KNIME": "visualization_scripts/36_workflow_generated_code_validation_KNIME_data.json",
    "Python": "visualization_scripts/36_workflow_generated_code_validation_Python_data.json"
}
EXPORT_DIR = "visualization_scripts/barcharts_images"
os.makedirs(EXPORT_DIR, exist_ok=True)


# === Data Loading ===

def load_data(source: str) -> list:
    """
    Load the workflow data corresponding to the selected platform.

    Args:
        source (str): Platform name ('KNIME' or 'Python').

    Returns:
        list: List of workflow dictionaries with node validation results.
    """
    with open(DATA_PATHS[source], 'r') as f:
        return json.load(f)["workflows"]


# === Chart Generation ===

def generate_bar_chart(source: str, x_axis_type: str) -> str:
    """
    Generate a bar chart based on the selected data platform and X-axis type.

    Args:
        source (str): Platform name.
        x_axis_type (str): X-axis variable ('Subworkflows', 'Tipo de contrato', 'Tipo de nodo').

    Returns:
        str: File path of the temporarily saved chart image.
    """
    workflows = load_data(source)
    fig, ax = plt.subplots(figsize=(12, 6))

    # Identify all unique result types present
    all_results = set()
    for wf in workflows:
        for node in wf["nodes"]:
            for contracts in node.values():
                all_results.update(contracts.values())

    all_results = sorted(all_results)

    def get_color(res):
        if res == "VALIDATED":
            return "green"
        elif res == "NOT VALIDATED":
            return "red"
        else:
            return "gray"

    color_map = {res: get_color(res) for res in all_results}

    def count_contracts(nodes):
        counts = {res: 0 for res in all_results}
        for node in nodes:
            for contracts in node.values():
                for result in contracts.values():
                    if result in counts:
                        counts[result] += 1
        return counts

    if x_axis_type == "Subworkflows":
        x_labels = []
        result_counts = {res: [] for res in all_results}
        for wf in workflows:
            x_labels.append(wf["name"])
            counts = count_contracts(wf["nodes"])
            for res in all_results:
                result_counts[res].append(counts[res])
        x = range(len(x_labels))
        bottom = [0] * len(x_labels)
        for res in all_results:
            ax.bar(x, result_counts[res], bottom=bottom, color=color_map[res], label=res)
            bottom = [b + rc for b, rc in zip(bottom, result_counts[res])]
        ax.set_xticks(x)
        ax.set_xticklabels(x_labels, rotation=90)

    elif x_axis_type == "Tipo de contrato":
        contract_types = ["PRECONDITION", "POSTCONDITION", "INVARIANT"]
        result_counts = {res: [] for res in all_results}
        for ctype in contract_types:
            counts = {res: 0 for res in all_results}
            for wf in workflows:
                for node in wf["nodes"]:
                    for contracts in node.values():
                        result = contracts.get(ctype)
                        if result in counts:
                            counts[result] += 1
            for res in all_results:
                result_counts[res].append(counts[res])
        x = range(len(contract_types))
        bottom = [0] * len(contract_types)
        for res in all_results:
            ax.bar(x, result_counts[res], bottom=bottom, color=color_map[res], label=res)
            bottom = [b + rc for b, rc in zip(bottom, result_counts[res])]
        ax.set_xticks(x)
        ax.set_xticklabels(contract_types)

    elif x_axis_type == "Tipo de nodo":
        node_counts = defaultdict(lambda: {res: 0 for res in all_results})
        for wf in workflows:
            for node in wf["nodes"]:
                for node_type, contracts in node.items():
                    for result in contracts.values():
                        if result in all_results:
                            node_counts[node_type][result] += 1
        x_labels = list(node_counts.keys())
        result_counts = {res: [node_counts[k][res] for k in x_labels] for res in all_results}
        x = range(len(x_labels))
        bottom = [0] * len(x_labels)
        for res in all_results:
            ax.bar(x, result_counts[res], bottom=bottom, color=color_map[res], label=res)
            bottom = [b + rc for b, rc in zip(bottom, result_counts[res])]
        ax.set_xticks(x)
        ax.set_xticklabels(x_labels, rotation=90)

    # Add margin to the top of the chart
    max_height = max(sum(values) for values in zip(*result_counts.values()))
    ax.set_ylim(top=max_height * 1.10)
    ax.set_ylabel("Number of instances")
    ax.set_title(f"Results by {x_axis_type}")
    ax.legend(loc="upper right")
    plt.tight_layout()

    # Save chart with configuration-dependent filename
    filename = f"chart_{source}_{x_axis_type.replace(' ', '_')}.png"
    file_path = os.path.join(EXPORT_DIR, filename)
    plt.savefig(file_path)
    plt.close(fig)

    return file_path


# === Image Export ===

def export_image():
    """
    Export the most recently generated chart under a fixed name (for compatibility).

    Returns:
        str: Message indicating the export result.
    """
    latest_image = next(
        (f for f in sorted(os.listdir(EXPORT_DIR), reverse=True) if f.startswith("chart_") and f.endswith(".png")),
        None
    )
    if latest_image:
        export_path = os.path.join(EXPORT_DIR, "exported_chart.png")
        latest_path = os.path.join(EXPORT_DIR, latest_image)
        os.replace(latest_path, export_path)
        return f"Chart exported as: {export_path}"
    return "No chart available for export."


# === GUI Construction ===

with gr.Blocks(title="Contract Validation Results for 36 Subworkflows") as demo:
    gr.Markdown("## Contract Validation Results for 36 Subworkflows")

    with gr.Group():
        gr.Markdown("### Generated Data Platform")
        source = gr.Radio(choices=["KNIME", "Python"], value="KNIME", label="Select the platform")

    with gr.Group():
        gr.Markdown("### X-Axis Variable")
        x_axis = gr.Radio(
            choices=["Tipo de nodo", "Tipo de contrato", "Subworkflows"],
            value="Subworkflows",
            label="Select X-axis variable"
        )

    with gr.Group():
        gr.Markdown("### Results Visualization")
        chart = gr.Image(type="filepath", label="Generated Chart")

    with gr.Group():
        gr.Markdown("### Export Image")
        gr.Markdown("Exported charts will be saved in `visualization_scripts/barcharts_images`")
        export_btn = gr.Button("Export Image")
        export_msg = gr.Textbox(label="Export Message")

    # Event-driven rendering and export
    source.change(fn=generate_bar_chart, inputs=[source, x_axis], outputs=chart)
    x_axis.change(fn=generate_bar_chart, inputs=[source, x_axis], outputs=chart)
    export_btn.click(fn=export_image, inputs=[], outputs=export_msg)

    # Initial rendering
    chart.value = generate_bar_chart("KNIME", "Subworkflows")

# === Run Application ===

if __name__ == "__main__":
    demo.launch()
